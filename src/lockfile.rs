use std::{fs::File, io::{Read, Write}};

use anyhow::{bail, Context, Result};
use camino::Utf8PathBuf;
use serde::{Deserialize, Serialize};

/// The standard file name used for the lockfile on disk.
pub const LOCKFILE_NAME: &str = "Skeleton.lock";

const HEADER_COMMENT: &str = r##"# This file is automatically @generated by Cargo Skeleton.
It is not intended for manual editing.

"##;

// TODO: we should probably track the flags used when it was generated,
// so we can bail if they do not match when we build.
// And probably a version too, in case the layer cache is stale.

/// Meta information for all local packages within a skeleton
/// directory tree. The lockfile records the exact dependencies
/// needed to build the package as resolved by Cargo.
#[derive(Debug, Default, Serialize, Deserialize)]
pub struct Lockfile {
    #[serde(rename = "package")]
    pub packages: Vec<Package>,
}

impl Lockfile {
    pub fn to_string(&mut self) -> String {
        self.packages.sort();
        for pkg in self.packages.iter_mut() {
            pkg.dependencies.sort();
        }

        let mut out = String::new();

        out.push_str(&HEADER_COMMENT);
        out.push_str(&toml::to_string_pretty(&self).unwrap());
        out.push_str("\n");

        out
    }
}

/// An opaque identifier for a package.
#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(transparent)]
#[repr(transparent)]
pub struct PackageId(String);

impl PackageId {
    fn new(id: impl Into<String>) -> Self {
        Self(id.into())
    }

    fn as_str(&self) -> &str {
        &self.0
    }
}

impl From<&str> for PackageId {
    fn from(value: &str) -> Self {
        Self(value.to_string())
    }
}

impl From<String> for PackageId {
    fn from(value: String) -> Self {
        Self(value)
    }
}

/// Meta information for a local package.
/// Only the information necessary to build the package's dependencies is retained.
#[derive(Debug, PartialEq, PartialOrd, Eq, Ord, Serialize, Deserialize)]
pub struct Package {
    /// The name field as given in Cargo.toml
    pub name: String,
    /// An opaque identifier for the package
    pub id: PackageId,
    /// The IDs of the resolved direct dependencies of the package
    pub dependencies: Vec<PackageId>,
}

/// Load the workspace's lockfile from disk.
pub fn load_lockfile(workspace_root: Utf8PathBuf) -> Result<Lockfile> {
    let path = workspace_root.join(LOCKFILE_NAME);

    if !path.exists() {
        bail!(
            "Failed to read {} from workspace directory {}",
            LOCKFILE_NAME,
            workspace_root
        );
    }

    let mut file = File::open(path).context("opening lockfile")?;

    let mut buf = String::new();

    file.read_to_string(&mut buf).context("reading lockfile")?;

    let lockfile: Lockfile = toml::from_str(&buf).context("parsing lockfile")?;

    Ok(lockfile)
}

/// Write the lockfile to disk.
pub fn write_lockfile(workspace_root: Utf8PathBuf, lockfile: &mut Lockfile) -> Result<()> {
    let path = workspace_root.join(LOCKFILE_NAME);

    let mut file = File::create(path).context("opening lockfile")?;

    let data = lockfile.to_string();

    file.write_all(data.as_bytes()).context("writing lockfile")?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn lockfile_to_string() {
        let mut lockfile = Lockfile {
            packages: vec![
                Package {
                    name: "foo".into(),
                    id: "file:///foo".into(),
                    dependencies: vec![
                        "file:///bar".into(),
                        "baz".into(),
                    ],
                },
                Package {
                    name: "bar".into(),
                    id: "file:///bar".into(),
                    dependencies: vec![
                        "baz".into(),
                    ],
                }
            ],
        };

        let out = lockfile.to_string();

        let expected = r##"# This file is automatically @generated by Cargo Skeleton.
It is not intended for manual editing.

[[package]]
name = "bar"
id = "file:///bar"
dependencies = ["baz"]

[[package]]
name = "foo"
id = "file:///foo"
dependencies = [
    "baz",
    "file:///bar",
]

"##;

        assert_eq!(expected, out);
    }
}
