use std::{env, fs::File, io::{Read, Write}};
use anyhow::{bail, Context, Result};
use camino::Utf8PathBuf;
use cargo_metadata::{CargoOpt, Metadata, MetadataCommand, Package, Target};
use cargo_util_schemas::manifest::{PathValue, TomlManifest, TomlTarget};
use log::*;

pub const DEFAULT_OUT_PATH: &str = "skeleton.tar";

const LIB_STUB: &str = r#"
// File generated by `cargo skeleton`. DO NOT EDIT.
"#;

const BIN_STUB: &str = r#"
// File generated by `cargo skeleton`. DO NOT EDIT.
fn main() {
    panic!("Attempted to execute skeleton file {}", file!());
}
"#;

#[derive(Debug, Default)]
pub struct BuildOptions {
    pub manifest_path: Option<Utf8PathBuf>,
    pub out_path: Option<Utf8PathBuf>,
}

struct Builder<W: Write> {
    root_path: Utf8PathBuf,
    ar: tar::Builder<W>,
}

impl<W: Write> Builder<W> {
    pub fn new(root_path: impl Into<Utf8PathBuf>, out: W) -> Self {
        let root_path = root_path.into();
        let ar = tar::Builder::new(out);

        Self {
            root_path,
            ar,
        }
    }

    pub fn build(mut self, metadata: &Metadata) -> Result<()> {
        env::set_current_dir(&metadata.workspace_root)
            .context("changing current directory to workspace root")?;

        self.add_root_cargo_files(metadata)?;

        // TODO: sort so it's deterministic
        for package in metadata.packages.iter() {
            self.add_package(package)?;
        }

        self.ar.into_inner().context("building tar archive")?;

        Ok(())
    }

    pub fn add_root_cargo_files(&mut self, metadata: &Metadata) -> Result<()> {
        if !self.has_root_package(metadata) {
            self.ar.append_path("Cargo.toml")
                .context("adding root manifest to archive")?;
        }

        self.ar.append_path("Cargo.lock")
            .context("adding root Cargo.lock to archive")?;

        Ok(())
    }

    fn has_root_package(&self, metadata: &Metadata) -> bool {
        for package in metadata.packages.iter() {
            if package.manifest_path == self.root_path {
                return true;
            }
        }

        return false;
    }

    pub fn add_package(&mut self, package: &Package) -> Result<()> {
        let manifest_path = self.make_relative(&package.manifest_path)
            .context("resolving package manifest path")?;

        self.add_manifest(&manifest_path)
            .context("adding package manifest")?;

        // TODO: sort so it's deterministic
        for target in package.targets.iter() {
            self.add_target(&target)
                .context("adding package target to archive")?;
        }

        // TODO: these files will affect compilation and should be added too:
        // - build.rs
        // - .cargo/config(.toml)?
        // - rust-toolchain(.toml)?
        // Because build.rs could reference anything, we probably should allow
        // using the manifest `metadata` field to reference arbitrary files that
        // should be included too.

        Ok(())
    }

    fn add_manifest(&mut self, path: &Utf8PathBuf) -> Result<()> {
        let mut file = File::open(path).context("opening manifest file")?;

        let mut buf = String::new();

        file.read_to_string(&mut buf).context("reading manifest file")?;

        let mut manifest: TomlManifest = toml::from_str(&buf)
            .context("parsing TOML manifest")?;

        if let Some(ref mut target) = manifest.lib {
            stub_target_path(target);
        }
        if let Some(ref mut bin) = manifest.bin {
            for target in bin.iter_mut() {
                stub_target_path(target);
            }
        }
        if let Some(ref mut test) = manifest.test {
            for target in test.iter_mut() {
                stub_target_path(target);
            }
        }
        if let Some(ref mut example) = manifest.test {
            for target in example.iter_mut() {
                stub_target_path(target);
            }
        }
        if let Some(ref mut bench) = manifest.test {
            for target in bench.iter_mut() {
                stub_target_path(target);
            }
        }

        let data = toml::to_string_pretty(&manifest)
            .context("encoding manifest")?;

        let mut header = tar::Header::new_gnu();

        header.set_metadata(&file.metadata().unwrap());
        // header.set_mtime(0);
        // header.set_uid(0);
        // header.set_gid(0);
        // header.set_mode(0o644);
        // header.set_entry_type(tar::EntryType::Regular);
        header.set_size(data.len().try_into().expect("no overflow"));
        header.set_cksum();

        self.ar.append_data(&mut header, path, data.as_bytes())
            .context("adding manifest to archive")?;

        Ok(())
    }

    fn add_target(&mut self, target: &Target) -> Result<()> {
        let mut path = self.make_relative(&target.src_path)
            .context("resolving target path")?;

        path = with_stub_suffix(path);

        let data = if target.is_bin() || target.is_bench() || target.is_test() || target.is_example() {
            BIN_STUB
        } else {
            LIB_STUB
        };

        let mut header = tar::Header::new_gnu();
        header.set_mtime(0);
        header.set_uid(0);
        header.set_gid(0);
        header.set_mode(0o644);
        header.set_entry_type(tar::EntryType::Regular);
        header.set_size(data.len().try_into().expect("no overflow"));
        header.set_cksum();

        self.ar.append_data(&mut header, path, data.as_bytes())
            .context("adding target stub to archive")?;

        Ok(())
    }

    fn make_relative(&self, path: &Utf8PathBuf) -> Result<Utf8PathBuf> {
        if !path.starts_with(&self.root_path) {
            bail!("Path outside of workspace root");
        }

        Ok(path
            .strip_prefix(&self.root_path)
            .expect("path inside workspace")
            .to_owned())
    }
}

pub fn build(opts: BuildOptions) -> Result<()> {
    let mut cmd = MetadataCommand::new();

    if let Some(manifest_path) = opts.manifest_path {
        cmd.manifest_path(manifest_path);
    }

    let metadata = cmd
        .features(CargoOpt::AllFeatures)
        .no_deps()
        .exec()
        .context("running cargo metadata")?;

    info!("Using workspace root: {}", metadata.workspace_root);

    let out_path = opts.out_path
        .unwrap_or_else(|| DEFAULT_OUT_PATH.try_into()
        .expect("valid path"));

    info!("Writing to {}", out_path);

    let file = File::create(out_path)
        .context("opening out file")?;

    let builder = Builder::new(&metadata.workspace_root, file);

    builder.build(&metadata)?;

    Ok(())
}

fn stub_target_path(target: &mut TomlTarget) {
    if let Some(ref mut path) = target.path {
        let path: Utf8PathBuf = path.to_owned().0.try_into()
            .expect("cargo requires utf-8 paths");

        target.path = Some(PathValue(with_stub_suffix(path).into()))
    }
}

fn with_stub_suffix(mut path: Utf8PathBuf) -> Utf8PathBuf {
    if path.file_stem().is_some() {
        let mut file_name = path.file_stem().unwrap().to_owned();
        file_name.push_str("_stub");
        if let Some(ext) = path.extension() {
            file_name.push('.');
            file_name.push_str(ext);
        }

        path.set_file_name(file_name);
    }

    path
}