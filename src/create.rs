use crate::{lockfile::LOCKFILE_NAME, workspace::Workspace};
use anyhow::{Context, Result};
use camino::Utf8PathBuf;
use cargo_metadata::{CargoOpt, MetadataCommand, Target};
use itertools::Itertools;
use log::*;
use std::{env, fs::File};

pub const DEFAULT_OUT_PATH: &str = "skeleton.tar";

const LIB_STUB: &str = r#"
// This file is automatically @generated by Cargo Skeleton.
// It is not intended for manual editing.
compile_error!("Attempted to compile skeleton file {}", file!());

"#;

const BIN_STUB: &str = r#"
// This file is automatically @generated by Cargo Skeleton.
// It is not intended for manual editing.
compile_error!("Attempted to compile skeleton file {}", file!());

fn main() {}

"#;

/// Paths for additional config files that affect compilation.
const CONFIG_PATHS: &[&str] = &[
    ".cargo/config",
    ".cargo/config.toml",
    "rust-toolchain",
    "rust-toolchain.toml",
];

#[derive(Debug, Default)]
pub struct CreateOptions {
    pub manifest_path: Option<Utf8PathBuf>,
    pub out_path: Option<Utf8PathBuf>,
}

pub fn create_skeleton(opts: CreateOptions) -> Result<()> {
    let mut cmd = MetadataCommand::new();

    if let Some(manifest_path) = opts.manifest_path {
        cmd.manifest_path(manifest_path);
    }

    let metadata = cmd
        // TODO: we need better customization here.
        .features(CargoOpt::AllFeatures)
        .exec()
        .context("running cargo metadata")?;

    info!("Using workspace root: {}", metadata.workspace_root);

    let out_path = opts
        .out_path
        .unwrap_or_else(|| DEFAULT_OUT_PATH.try_into().expect("valid path"));

    info!("Writing to {}", out_path);

    let root = &metadata.workspace_root;

    env::set_current_dir(root).context("changing current directory to workspace root")?;

    let file = File::create(out_path).context("opening out file")?;

    let mut ar = tar::Builder::new(file);

    if metadata.root_package().is_none() {
        ar.append_path("Cargo.toml")
            .context("adding root manifest to archive")?;
    }

    ar.append_path("Cargo.lock")?;

    for path in CONFIG_PATHS.iter() {
        if root.join(path).exists() {
            ar.append_path(path)
                .context(format!("adding config file to archive: {}", path))?;
        }
    }

    let packages = metadata
        .packages
        .iter()
        .filter(|pkg| pkg.source == None && pkg.manifest_path.starts_with(root))
        .sorted_by(|a, b| Ord::cmp(&a.name, &b.name));

    for package in packages {
        let path = package.manifest_path.strip_prefix(root).unwrap();
        ar.append_path(path)
            .context(format!("adding package manifest to archive: {}", path))?;

        let targets = package
            .targets
            .iter()
            .sorted_by(|a, b| Ord::cmp(&a.name, &b.name));

        for target in targets {
            let path = target.src_path.strip_prefix(root).unwrap();
            let data = target_stub(target);
            let mut header = data_header(data.len() as u64);

            ar.append_data(&mut header, path, data.as_bytes())
                .context(format!("Adding target stub to archive: {}", path))?;
        }
    }

    let workspace = {
        let mut workspace = Workspace::new(root.clone());
        workspace.load_metadata(&metadata)?;
        workspace
    };
    let mut lockfile = workspace.into_lockfile();

    let lock_data = lockfile.to_string();
    let mut header = data_header(lock_data.len() as u64);

    ar.append_data(&mut header, LOCKFILE_NAME, lock_data.as_bytes())
        .context("Adding skeleton lockfile to archive")?;

    ar.into_inner().context("building tar archive")?;

    Ok(())
}

fn data_header(size: u64) -> tar::Header {
    let mut header = tar::Header::new_gnu();
    header.set_mtime(0);
    header.set_uid(0);
    header.set_gid(0);
    header.set_mode(0o644);
    header.set_entry_type(tar::EntryType::Regular);
    header.set_size(size);
    header.set_cksum();

    header
}

fn target_stub(target: &Target) -> &'static str {
    if target.is_bin()
        || target.is_bench()
        || target.is_test()
        || target.is_example()
    {
        BIN_STUB
    } else {
        LIB_STUB
    }
}
